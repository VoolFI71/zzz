from __future__ import annotations

import asyncio
import base64
import json
import logging
import os
import random
import time
import uuid
from typing import Any, Dict, List

import httpx
from fastapi import (
    APIRouter,
    Depends,
    Header,
    HTTPException,
    Query,
    Request,
)
from fastapi.responses import HTMLResponse, JSONResponse, PlainTextResponse, RedirectResponse, Response
from fastapi.templating import Jinja2Templates

from database import db
from fastapi import FastAPI
from models import models

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
# ---------------------------------------------------------------------------

AUTH_CODE: str | None = os.getenv("AUTH_CODE")

if AUTH_CODE is None:
    logger.warning("ENV AUTH_CODE is not set ‚Äì all requests will be rejected")

def _get_cookie(server_code: str) -> str:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç cookie –¥–ª—è –ø–∞–Ω–µ–ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞.

    –ò—â–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è –≤–∏–¥–∞ ``COOKIE_fi`` (—Ä–µ–≥–∏—Å—Ç—Ä –Ω–µ –≤–∞–∂–µ–Ω).
    –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ ‚Äì –≤–µ—Ä–Ω—ë—Ç –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É.
    """
    return os.getenv(f"COOKIE_{server_code.lower()}", "")

# –ó–Ω–∞—á–µ–Ω–∏—è —á–∏—Ç–∞–µ–º –∏–∑ .env, —á—Ç–æ–±—ã –Ω–µ —Ö—Ä–∞–Ω–∏—Ç—å –≤ –∫–æ–¥–µ
def _env_any(*keys: str, default: str = "") -> str:
    for key in keys:
        value = os.getenv(key)
        if value:
            return value
    return default

COUNTRY_SETTINGS: dict[str, dict[str, str]] = {
    "nl": {
        "urlcreate": _env_any("URLCREATE_NL", "urlcreate_nl", default=""),
        "urlupdate": _env_any("URLUPDATE_NL", "urlupdate_nl", default=""),
        "urldelete": _env_any("URLDELETE_NL", "urldelete_nl", default=""),
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ VLESS
        "host": _env_any("HOST_NL", "host_nl", default="146.103.102.21"),
        "pbk": _env_any("PBK_NL", "pbk_nl", default=""),
        "sni": "google.com",
        "sid": _env_any("SID_NL", "sid_nl", default=""),
    },
    "fi": {
        "urlcreate": _env_any("URLCREATE_FI", "urlcreate_fi", default=""),
        "urlupdate": _env_any("URLUPDATE_FI", "urlupdate_fi", default=""),
        "urldelete": _env_any("URLDELETE_FI", "urldelete_fi", default=""),
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ VLESS
        "host": _env_any("HOST_FI", "host_fi", default="77.110.108.194"),
        "pbk": _env_any("PBK_FI", "pbk_fi", default=""),
        "sni": "www.vk.com",
        "sid": _env_any("SID_FI", "sid_fi", default=""),
    },
}

COUNTRY_LABELS: dict[str, str] = {
    "nl": "Netherlands üá≥üá±",
    "fi": "Finland üá´üáÆ",
}

def _is_browser_request(headers: dict[str, str]) -> bool:
    """–ì—Ä—É–±–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –±—Ä–∞—É–∑–µ—Ä–∞ –¥–ª—è –∫–æ–Ω—Ç–µ–Ω—Ç-nega.

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True –¥–ª—è –±—Ä–∞—É–∑–µ—Ä–æ–≤ (–æ—Ç–¥–∞—ë–º HTML), False –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤/–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π (–æ—Ç–¥–∞—ë–º text/plain).
    """
    ua = headers.get("user-agent", "").lower()
    accept = headers.get("accept", "").lower()
    # –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –±—Ä–∞—É–∑–µ—Ä—ã –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç Sec-Fetch-* –∏/–∏–ª–∏ ch-ua –∑–∞–≥–æ–ª–æ–≤–∫–∏
    has_sec_fetch = any(h in headers for h in ("sec-fetch-mode", "sec-fetch-site", "sec-ch-ua"))
    if has_sec_fetch:
        return True
    # –Ø–≤–Ω–æ HTML –≤ Accept ‚Üí –±—Ä–∞—É–∑–µ—Ä
    if "text/html" in accept:
        return True
    # –ü–æ User-Agent
    browser_markers = ("mozilla", "chrome", "safari", "firefox", "edg/")
    if any(marker in ua for marker in browser_markers):
        return True
    return False


router = APIRouter()
templates = Jinja2Templates(directory="templates")
BASE_URL: str = os.getenv("BASE_URL", "https://swaga.space")

# Subscription response metadata (v2RayTun headers)
SUB_TITLE: str = _env_any("SUBSCRIPTION_TITLE", "sub_title", default="GLS VPN")
SUB_UPDATE_HOURS: str = _env_any("SUBSCRIPTION_UPDATE_HOURS", "sub_update_hours", default="12")
SUB_ANNOUNCE: str = _env_any("SUBSCRIPTION_ANNOUNCE", "sub_announce", default="")
SUB_ANNOUNCE_URL: str = _env_any("SUBSCRIPTION_ANNOUNCE_URL", "sub_announce_url", default="")
SUB_ROUTING_B64: str = _env_any("SUBSCRIPTION_ROUTING_B64", "sub_routing_b64", default="")

# ---------------------------------------------------------------------------
# Dependencies
# ---------------------------------------------------------------------------

async def verify_api_key(x_api_key: str = Header(...)) -> None:  # noqa: D401
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å API-–∫–ª—é—á–∞.

    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ *dependency* –≤–æ –≤—Å–µ—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–∞—Ö.
    """
    if x_api_key != AUTH_CODE:
        raise HTTPException(status_code=403, detail="–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞")




# ---------------------------------------------------------------------------
# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
# ---------------------------------------------------------------------------

def build_payload(uid: str, enable: bool, expiry_time: int = 0) -> Dict[str, Any]:
    """–§–æ—Ä–º–∏—Ä—É–µ—Ç payload –¥–ª—è –ø–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è."""
    return {
        "id": 1,
        "settings": json.dumps(
            {
                "clients": [
                    {
                        "id": uid,
                        "flow": "xtls-rprx-vision",
                        "email": str(random.randint(10_000_000, 100_000_000)),
                        "limitIp": 1,
                        "totalGB": 0,
                        "expiryTime": expiry_time * 1000 if expiry_time else 0,
                        "enable": enable,
                        "tgId": "",
                        "subId": str(random.randint(10_000_000, 100_000_000)),
                        "comment": "",
                        "reset": 0,
                    }
                ]
            }
        ),
    }


async def panel_request(request: Request, url: str, server_code: str, payload: Dict[str, Any] | None = None) -> httpx.Response:
    """–ü–æ–º–æ—â–Ω–∏–∫ –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –ø–∞–Ω–µ–ª–∏."""
    headers = {
        "Content-Type": "application/json",
        "Cookie": _get_cookie(server_code),
    }
    # –ë–µ—Ä—ë–º –æ–±—â–∏–π –∫–ª–∏–µ–Ω—Ç –∏–∑ app.state
    async def _do_request(client: httpx.AsyncClient) -> httpx.Response:
        if payload is None:
            return await client.post(url, headers=headers)
        return await client.post(url, json=payload, headers=headers)

    # –†–µ—Ç—Ä–∞–∏ –Ω–∞ —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏
    last_exc: Exception | None = None
    for attempt in range(3):
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∫–ª–∏–µ–Ω—Ç–∞ –∏–∑ request.app.state
            http_client = getattr(request.app.state, "http_client", None)
            if http_client is not None:
                return await _do_request(http_client)
            # Fallback: –ª–æ–∫–∞–ª—å–Ω—ã–π –∫–ª–∏–µ–Ω—Ç (–Ω–µ –¥–æ–ª–∂–Ω–æ —á–∞—Å—Ç–æ —Å—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å)
            async with httpx.AsyncClient(timeout=15, follow_redirects=True) as tmp_client:
                return await _do_request(tmp_client)
        except httpx.RequestError as exc:
            last_exc = exc
            await asyncio.sleep(0.3 * (attempt + 1))
    logger.error("HTTP request to %s failed after retries: %s", url, last_exc)
    raise HTTPException(status_code=502, detail="–û—à–∏–±–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ –ø–∞–Ω–µ–ª–∏")


# ---------------------------------------------------------------------------
# –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã
# ---------------------------------------------------------------------------

@router.post(
    "/createconfig",
    response_model=List[str],
)
async def create_config(
    client_data: models.CreateData,
    request: Request,
    _: None = Depends(verify_api_key),
) -> List[str]:
    """–°–æ–∑–¥–∞—ë—Ç `client_data.count` –Ω–æ–≤—ã—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏—Ö –≤ –ë–î."""

    created_ids: list[str] = []

    for _ in range(client_data.count):
        uid = str(uuid.uuid4())
        payload = build_payload(uid, enable=False)

        url = COUNTRY_SETTINGS[client_data.server]["urlcreate"]
        logger.info("panel.create URL=%s", url)
        response = await panel_request(request, url, client_data.server, payload)

        if response.status_code == 200:
            await db.insert_into_db(
                tg_id=None,
                user_code=uid,
                time_end=0,
                server_country=client_data.server,
            )
            created_ids.append(uid)
            logger.info("Config %s created", uid)
        else:
            logger.error(
                "Failed to create config, status=%s, body=%s",
                response.status_code,
                response.text,
            )
            raise HTTPException(
                status_code=response.status_code,
                detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏",
            )

    return created_ids


@router.post(
    "/giveconfig",
    response_model=str,
)
async def give_config(
    client_data: models.ClientData,
    request: Request,
    _: None = Depends(verify_api_key),
) -> str:
    """–ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç —Å–≤–æ–±–æ–¥–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∞—Ç–æ–º–∞—Ä–Ω–æ–π –±—Ä–æ–Ω—å—é."""

    # 1) –ü—ã—Ç–∞–µ–º—Å—è –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–±–æ–¥–Ω—ã–π –∫–æ–Ω—Ñ–∏–≥ –∞—Ç–æ–º–∞—Ä–Ω–æ
    reserved_uid = await db.reserve_one_free_config(
        reserver_tg_id=str(client_data.id),
        server_country=client_data.server,
        reservation_ttl_seconds=120,
    )
    if not reserved_uid:
        raise HTTPException(
            status_code=409,
            detail="–°–≤–æ–±–æ–¥–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É",
        )

    expiry_unix = int(time.time()) + (60 * 60 * 24 * client_data.time)
    payload = build_payload(reserved_uid, enable=True, expiry_time=expiry_unix)
    url = COUNTRY_SETTINGS[client_data.server]["urlupdate"] + reserved_uid
    logger.info("panel.update URL=%s", url)

    # 2) –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω—Ñ–∏–≥ –Ω–∞ –ø–∞–Ω–µ–ª–∏
    response = await panel_request(request, url, client_data.server, payload)

    if response.status_code != 200:
        # –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –±—Ä–æ–Ω—å, —á—Ç–æ–±—ã –∫–æ–Ω—Ñ–∏–≥ —Å–Ω–æ–≤–∞ —Å—Ç–∞–ª –¥–æ—Å—Ç—É–ø–µ–Ω
        try:
            await db.cancel_reserved_config(reserved_uid, str(client_data.id))
        finally:
            pass
        raise HTTPException(
            status_code=response.status_code,
            detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–∞ –ø–∞–Ω–µ–ª–∏",
        )

    # 3) –§–∏–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –±—Ä–æ–Ω—å –≤ –ë–î
    finalized = await db.finalize_reserved_config(
        user_code=reserved_uid,
        reserver_tg_id=str(client_data.id),
        final_time_end=expiry_unix,
        server_country=client_data.server,
    )
    if finalized == 0:
        # –ú–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω—ã–π —Å–ª—É—á–∞–π: –±—Ä–æ–Ω—å –∏—Å—Ç–µ–∫–ª–∞ –∏–ª–∏ –ø–æ—Ç–µ—Ä—è–Ω–∞; –ø—Ä–æ–±—É–µ–º –æ—Ç–º–µ–Ω–∏—Ç—å –Ω–∞ –ø–∞–Ω–µ–ª–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –∑–¥–µ—Å—å
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É, –ø—Ä–æ—Å–∏–º –ø–æ–¥–¥–µ—Ä–∂–∫—É
        logger.error(
            "Finalization failed for uid %s (tg_id %s, server %s) after panel success",
            reserved_uid,
            client_data.id,
            client_data.server,
        )
        # –ü–æ–ø—Ä–æ–±—É–µ–º —Å–Ω—è—Ç—å –±—Ä–æ–Ω—å –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
        try:
            await db.cancel_reserved_config(reserved_uid, str(client_data.id))
        finally:
            pass
        raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞ —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏–∏. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.")

    logger.info(
        "Config %s activated for tg_id %s on server %s",
        reserved_uid,
        client_data.id,
        client_data.server,
    )
    # Ensure a permanent subscription key is created for this user (idempotent)
    try:
        await db.get_or_create_sub_key(str(client_data.id))
    except Exception:
        pass
    return reserved_uid


@router.post(
    "/extendconfig",
    response_model=str,
)
async def extend_config(
    update_data: models.ExtendConfig,
    request: Request,
    _: None = Depends(verify_api_key),
) -> str:
    """–ü—Ä–æ–¥–ª–µ–≤–∞–µ—Ç —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–Ω—Ñ–∏–≥–∞ –Ω–∞ `update_data.time` —Å—É—Ç–æ–∫."""

    uid = update_data.uid
    added_seconds = update_data.time * 60 * 60 * 24

    current_time_end = await db.get_time_end_by_code(uid)
    if current_time_end is None:
        raise HTTPException(status_code=404, detail="–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    base_time = max(current_time_end, int(time.time()))
    new_time_end = base_time + added_seconds

    payload = build_payload(uid, enable=True, expiry_time=new_time_end)

    url = f"{COUNTRY_SETTINGS[update_data.server]['urlupdate']}{uid}"
    logger.info("panel.extend URL=%s", url)
    response = await panel_request(request, url, update_data.server, payload)

    if response.status_code == 200:
        await db.set_time_end(uid, new_time_end)
        logger.info("Config %s extended till %s (unix)", uid, new_time_end)
        return "–ö–æ–Ω—Ñ–∏–≥ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–¥–ª—ë–Ω"
    raise HTTPException(
        status_code=response.status_code,
        detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏",
    )


@router.delete(
    "/deleteconfig",
    response_model=str,
)
async def delete_config(
    data: models.DeleteConfig,
    request: Request,
    _: None = Depends(verify_api_key),
) -> str:
    """–£–¥–∞–ª—è–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø–æ –µ—ë `uid`."""

    uid = data.uid

    if await db.get_time_end_by_code(uid) is None:
        raise HTTPException(status_code=404, detail="–ö–æ–Ω—Ñ–∏–≥ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É–∂–µ —É–¥–∞–ª—ë–Ω")

    url = f"{COUNTRY_SETTINGS[data.server]['urldelete']}{uid}"
    logger.info("panel.delete URL=%s", url)
    response = await panel_request(request, url, data.server)

    if response.status_code != 200:
        logger.error(
            "Failed to delete config %s on panel: %s / %s",
            uid,
            response.status_code,
            response.text,
        )
        raise HTTPException(
            status_code=response.status_code,
            detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–∞ –ø–∞–Ω–µ–ª–∏",
        )

    rows = await db.delete_user_code(uid)
    if rows == 0:
        raise HTTPException(status_code=404, detail="–ö–æ–Ω—Ñ–∏–≥ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ë–î")

    logger.info("Config %s deleted", uid)
    return "–ö–æ–Ω—Ñ–∏–≥ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª—ë–Ω"


# ---------------------------------------------------------------------------
# –°–µ—Ä–≤–∏—Å–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
# ---------------------------------------------------------------------------

@router.delete(
    "/delete-all-configs",
    response_model=str,
)
async def delete_all_configs(request: Request, _: None = Depends(verify_api_key)) -> str:  # noqa: D401
    """–£–¥–∞–ª—è–µ—Ç –≤—Å–µ –∫–æ–Ω—Ñ–∏–≥–∏: —Å–Ω–∞—á–∞–ª–∞ –Ω–∞ –ø–∞–Ω–µ–ª–∏, –∑–∞—Ç–µ–º –≤ –ë–î."""
    rows = await db.get_all_user_codes()
    if not rows:
        return "–ù–µ—Ç –∫–æ–Ω—Ñ–∏–≥–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è"

    deleted, failed = 0, 0
    for uid, server in rows:
        # 1. –ü—ã—Ç–∞–µ–º—Å—è —É–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥ –Ω–∞ –ø–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        try:
            url = f"{COUNTRY_SETTINGS[server]['urldelete']}{uid}"
        except KeyError:
            logger.error("Unknown server country %s for uid %s", server, uid)
            failed += 1
            continue

        response = await panel_request(request, url, server)
        if response.status_code == 200:
            # 2. –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ –ë–î
            await db.delete_user_code(uid)
            deleted += 1
        else:
            logger.error(
                "Failed to delete config %s on panel: %s / %s",
                uid,
                response.status_code,
                response.text,
            )
            failed += 1

    logger.info("Bulk delete done: success=%s, failed=%s", deleted, failed)
    return f"–£–¥–∞–ª–µ–Ω–æ {deleted} –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π, –æ—à–∏–±–æ–∫ {failed}"

@router.get(
    "/check-available-configs",
)
async def check_available_configs(
    server: str | None = Query(
        default=None, description="–ö–æ–¥ —Å—Ç—Ä–∞–Ω—ã —Å–µ—Ä–≤–µ—Ä–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä `fi`"),
    _: None = Depends(verify_api_key),
):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤."""

    # –°–Ω–∞—á–∞–ª–∞ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∏—Å—Ç—ë–∫—à–∏–µ –∫–æ–Ω—Ñ–∏–≥–∏, —á—Ç–æ–±—ã –æ—Ç—Ä–∞–∑–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—É—é –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å
    try:
        await db.reset_expired_configs()
    except Exception:
        pass
    
    available_config = await db.get_one_expired_client(server)
    return JSONResponse(
        content={
            "available": bool(available_config),
            "message": (
                "–°–≤–æ–±–æ–¥–Ω—ã–µ –∫–æ–Ω—Ñ–∏–≥–∏ –¥–æ—Å—Ç—É–ø–Ω—ã"
                if available_config
                else "–°–≤–æ–±–æ–¥–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç"
            ),
        }
    )

@router.get(
    "/usercodes/{tg_id}",
)
async def read_user(tg_id: int, _: None = Depends(verify_api_key)):
    # –°–Ω–∞—á–∞–ª–∞ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∏—Å—Ç—ë–∫—à–∏–µ –∫–æ–Ω—Ñ–∏–≥–∏
    #await db.reset_expired_configs()
    try:
        await db.get_or_create_sub_key(str(tg_id))
    except Exception:
        pass
    users = await db.get_codes_by_tg_id(tg_id)
    if not users:
        raise HTTPException(status_code=404, detail="–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π")

    result = [
        {"user_code": user_code, "time_end": time_end, "server": server}
        for user_code, time_end, server in users
    ]
    return JSONResponse(content=result)


async def get_subscription(tg_id: int):
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤ –¥–ª—è V2rayTun.

    –î–æ–±–∞–≤–ª—è–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∏ (–∫–∞–∫ HTTP, —Ç–∞–∫ –∏ –≤ —Ç–µ–ª–µ) —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ —Å v2RayTun:
    - profile-title
    - subscription-userinfo (expire=...)
    - profile-update-interval (—á–∞—Å—ã)
    - routing (base64), announce, announce-url ‚Äî –µ—Å–ª–∏ –∑–∞–¥–∞–Ω—ã –≤ env
    """

    logger.info("Subscription request for tg_id: %s", tg_id)

    users = await db.get_codes_by_tg_id(tg_id)
    if not users:
        raise HTTPException(status_code=404, detail="–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π")

    current_time = int(time.time())
    active_configs: list[str] = []
    max_expire_unix: int = 0

    for user_code, time_end, server in users:
        if time_end > current_time:
            settings = COUNTRY_SETTINGS.get(server)
            if not settings:
                # –ï—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω ‚Äì –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                logger.warning("Unknown server %s for user_code %s", server, user_code)
                continue
            label = COUNTRY_LABELS.get(server, "SHARD VPN")
            vless_config = (
                f"vless://{user_code}@{settings['host']}:443?"
                f"security=reality&encryption=none&pbk={settings['pbk']}&"
                f"headerType=none&fp=chrome&type=tcp&flow=xtls-rprx-vision&"
                f"sni={settings['sni']}&sid={settings['sid']}#{label}"
            )
            active_configs.append(vless_config)
            if time_end > max_expire_unix:
                max_expire_unix = time_end

    if not active_configs:
        raise HTTPException(status_code=404, detail="–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π")

    # Compose optional body headers for compatibility
    body_header_lines: list[str] = []
    if SUB_TITLE:
        body_header_lines.append(f'profile-title: "{SUB_TITLE}"')
    if max_expire_unix > 0:
        body_header_lines.append(f'subscription-userinfo: "expire={max_expire_unix}"')
    if SUB_UPDATE_HOURS:
        body_header_lines.append(f'profile-update-interval: "{SUB_UPDATE_HOURS}"')
    if SUB_ROUTING_B64:
        body_header_lines.append(f'routing: "{SUB_ROUTING_B64}"')
    if SUB_ANNOUNCE:
        body_header_lines.append(f'announce: "{SUB_ANNOUNCE}"')
    if SUB_ANNOUNCE_URL:
        body_header_lines.append(f'announce-url: "{SUB_ANNOUNCE_URL}"')

    subscription_content = ("\n".join(body_header_lines + [""]) if body_header_lines else "") + "\n".join(active_configs)
    logger.info("Returning %s active configs for tg_id: %s (expire=%s)", len(active_configs), tg_id, max_expire_unix)

    # Also include headers at HTTP level
    response_headers: dict[str, str] = {"Content-Type": "text/plain; charset=utf-8"}
    if SUB_TITLE:
        response_headers["profile-title"] = SUB_TITLE
    if max_expire_unix > 0:
        response_headers["subscription-userinfo"] = f"expire={max_expire_unix}"
    if SUB_UPDATE_HOURS:
        response_headers["profile-update-interval"] = SUB_UPDATE_HOURS
    if SUB_ROUTING_B64:
        response_headers["routing"] = SUB_ROUTING_B64
    if SUB_ANNOUNCE:
        response_headers["announce"] = SUB_ANNOUNCE
    if SUB_ANNOUNCE_URL:
        response_headers["announce-url"] = SUB_ANNOUNCE_URL

    return PlainTextResponse(
        content=subscription_content,
        headers=response_headers,
    )

@router.get("/subscription/{sub_key}", response_class=HTMLResponse)
async def add_config_page(
    request: Request,
    config: str | None = None,
    expiry: int | None = None,
    sub_key: str | None = None,
    subscription: str | None = None,
):
    # –ö–æ–Ω—Ç–µ–Ω—Ç-–Ω–µ–≥–∞: –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –±—Ä–∞—É–∑–µ—Ä ‚Äî –æ—Ç–¥–∞—ë–º plain text (–¥–ª—è –∏–º–ø–æ—Ä—Ç–∞ –≤ V2rayTun)
    if not _is_browser_request({k.lower(): v for k, v in request.headers.items()}):
        # 1) –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω subscription=..., –æ—Ç–¥–∞–¥–∏–º –µ–≥–æ –∫–∞–∫ –µ—Å—Ç—å
        if subscription:
            return PlainTextResponse(content=subscription)
        # 2) –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω sub_key, —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –µ–≥–æ –≤ tg_id –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–¥–ø–∏—Å–∫—É
        if sub_key is not None:
            tg_id_str = await db.get_tg_id_by_key(sub_key)
            if tg_id_str is None:
                raise HTTPException(status_code=404, detail="subscription key not found")
            sub_resp = await get_subscription(int(tg_id_str))  # reuse —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ª–æ–≥–∏–∫–∏
            return PlainTextResponse(content=sub_resp.body.decode("utf-8"), headers=dict(sub_resp.headers))
        # 3) –ï—Å–ª–∏ –ø—Ä–∏—à—ë–ª config (vless/vmess/trojan), –æ—Ç–¥–∞–¥–∏–º –µ–≥–æ –∫–∞–∫ —Ç–µ–∫—Å—Ç
        if config:
            try:
                # –ï—Å–ª–∏ –ø—Ä–∏—à—ë–ª base64 ‚Äî –ø—Ä–æ–≤–µ—Ä–∏–º –∏ –¥–µ–∫–æ–¥–∏—Ä—É–µ–º
                decoded = base64.b64decode(config, validate=True).decode()
                if decoded.startswith(("vless://", "vmess://", "trojan://")):
                    return PlainTextResponse(content=decoded)
            except Exception:
                pass
            # –ò–Ω–∞—á–µ —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ —ç—Ç–æ —É–∂–µ —Å—ã—Ä–æ–π –∫–æ–Ω—Ñ–∏–≥
            return PlainTextResponse(content=config)
        # –ù–µ—á–µ–≥–æ –æ—Ç–¥–∞–≤–∞—Ç—å
        return PlainTextResponse(content="", status_code=204)
    # –ò–Ω–∞—á–µ —Ä–µ–Ω–¥–µ—Ä–∏–º HTML-—Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    return templates.TemplateResponse(
        "subscription.html",
        {"request": request, "config": config, "expiry": expiry, "sub_key": sub_key, "subscription": subscription},
    )

@router.get("/sub/{user_id}")
async def get_sub_key(user_id: str, _: None = Depends(verify_api_key)):
    try:
        sub_key = await db.get_or_create_sub_key(str(user_id))
    except Exception:
        raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    return JSONResponse({"sub_key": sub_key})




@router.get("/", response_class=HTMLResponse)
async def landing(request: Request):  # noqa: D401
    """–ö—Ä–∞—Å–æ—á–Ω–∞—è –ø–æ—Å–∞–¥–æ—á–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ VPN."""
    return templates.TemplateResponse("index.html", {"request": request})


# ---------------------------------------------------------------------------
# SEO: robots.txt –∏ sitemap.xml
# ---------------------------------------------------------------------------

@router.get("/robots.txt", include_in_schema=False)
async def robots_txt() -> PlainTextResponse:
    content = (
        "User-agent: *\n"
        "Allow: /\n"
        f"Sitemap: {BASE_URL}/sitemap.xml\n"
    )
    return PlainTextResponse(content=content, media_type="text/plain; charset=utf-8")


@router.get("/sitemap.xml", include_in_schema=False)
async def sitemap_xml() -> Response:
    urls: list[str] = [
        f"{BASE_URL}/",
        f"{BASE_URL}/subscription",
    ]
    urlset = "\n".join(
        f"  <url>\n    <loc>{loc}</loc>\n    <changefreq>weekly</changefreq>\n    <priority>0.8</priority>\n  </url>" for loc in urls
    )
    xml = (
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n"
        f"{urlset}\n"
        "</urlset>\n"
    )
    return Response(content=xml, media_type="application/xml")
